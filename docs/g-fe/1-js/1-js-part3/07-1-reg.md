---
sidebar_position: 7
---

# 정규 표현식   

연습사이트 : https://regex101.com/  

- [정규 표현식](#정규-표현식)
- [1.패턴과 플래그](#1패턴과-플래그)
    - [플래그](#플래그)
    - [str.match로 검색하기](#strmatch로-검색하기)
    - [str.replace로 치환하기](#strreplace로-치환하기)
    - [regexp.test로 일치 여부 확인하기](#regexptest로-일치-여부-확인하기)
- [2.문자 클래스](#2문자-클래스)
    - [문자클래스 (digit, space, word)](#문자클래스-digit-space-word)
    - [반대 클래스](#반대-클래스)
    - [점은 '아무 문자’에나 일치](#점은-아무-문자에나-일치)
    - [‘s’ 플래그와 점을 사용해 정말로 모든 문자 찾기](#s-플래그와-점을-사용해-정말로-모든-문자-찾기)
- [3.유니코드: 'u' 플래그와 \\p{...} 클래스](#3유니코드-u-플래그와-p-클래스)
    - [참고) 유니코드](#참고-유니코드)
  - [유니코드 프로퍼티 \\p{…}](#유니코드-프로퍼티-p)
- [4.앵커: 문자열의 시작 ^과 끝 $](#4앵커-문자열의-시작-과-끝-)
- [5.앵커 ^와 $의 여러 행 모드, 'm' 플래그](#5앵커-와-의-여러-행-모드-m-플래그)
- [6.Word boundary: \\b](#6word-boundary-b)

정규식을 이용하면 특정 문자열 패턴과 일치하는지 알 수 있다. 
- 글로벌 모드를 통해서 특정문자열과 일치하는 문자열들을 추출 할 수 있습니다.  
- 시작과 끝 엥커조건을 이용해서 문자열이 온전히 특정 패턴인지 알 수 있다.   

# 1.패턴과 플래그  

목적 : 문자 검색, 문자 교체, 문자 유효성 검사    
구성 : pattern + flag  

```js
// (동적) 패턴에 문자열 템플릿을 사용 가능.
regexp = new RegExp("pattern", "flags");  

// (정적) 아래 문법에서는, 정적인 패턴만 가능하다.  
regexp = /pattern/; // 플래그가 없음
regexp = /pattern/gmi; // 플래그 g, m, i가
```

### 플래그

**i**  
- i 플래그가 붙으면 대·소문자 구분 없이 검색합니다. 따라서 A와 a에 차이가 없습니다(아래 예시 참조).    

**g**    
- g 플래그가 붙으면 패턴과 일치하는 모든 것들을 찾습니다. g 플래그가 없으면 패턴과 일치하는 첫 번째 결과만 반환됩니다.    

m  
- 다중 행 모드(multiline mode)를 활성화합니다. 자세한 내용은 앵커 ^와 $의 여러 행 모드, 'm' 플래그에서 다룰 예정입니다.  

s  
- .이 개행 문자 \n도 포함하도록 ‘dotall’ 모드를 활성화합니다. 자세한 내용은 문자 클래스에서 다룰 예정입니다.    

u  
- 유니코드 전체를 지원합니다. 이 플래그를 사용하면 서로게이트 쌍(surrogate pair)을 올바르게 처리할 수 있습니다. 자세한 내용은 유니코드: 'u' 플래그와 \p{...} 클래스에서 다룰 예정입니다.  

y  
- 문자 내 특정 위치에서 검색을 진행하는 ‘sticky’ 모드를 활성화 시킵니다. 자세한 내용은 Sticky flag "y", searching at position에서 다룰 예정입니다.

### str.match로 검색하기  

일치하는 문자열의 index를 찾을때 유용하게 사용된다.    
- 1.g플래그를 이용해서 모두 선택할 것인지, 첫번째 요소만 고를것인지 가능.  
- 2.검색결과 없다면 null   

```js
let str = "We will, we will rock you";
str.match(/we/gi) // We,we (패턴과 일치하는 부분 문자열 두 개를 담은 배열)

---
let str = "We will, we will rock you";
let result = str.match(/we/i); // 플래그 g 없음
alert( result[0] );     // We (패턴에 일치하는 첫 번째 부분 문자열)
alert( result.length ); // 1
alert( result.index );  // 0 (부분 문자열의 위치)
alert( result.input );  // We will, we will rock you (원본 문자열)


```

### str.replace로 치환하기

- 1.g플래그가 없는 경우 패턴에 일치하는 첫 문자열부분만 교체 된다.    
- 2.g플래그가 있는 경우 패턴데 일치하는 모든 문자열이 교체 된다.  
- 3.패턴과 일치하는 부분문자열은 $& 이라고 지칭한다.  

```js
// 플래그 g 없음
alert( "We will, we will".replace(/we/i, "I") ); 
// I will, we will
- 대소문자 구분없으니 첫번째 We선택되며, g플래그가 없으니 이는 I로 변경되고 끝.
// 플래그 g 있음
alert( "We will, we will".replace(/we/ig, "I") ); 
// I will, I will

//$&를 사용한 예시를 살펴봅시다.
alert( "I love HTML".replace(/HTML/, "$& and JavaScript") );
// I love HTML and JavaScript

```

### regexp.test로 일치 여부 확인하기  

```js
let str = "I love JavaScript";
let regexp = /LOVE/i;

alert( regexp.test(str) ); // true

```


# 2.문자 클래스  

### 문자클래스 (digit, space, word)  

자주 사용하는 문자 클래스에는 다음 클래스가 있습니다.  

- \d ('digit(숫자)'의 ‘d’) : 숫자: 0에서 9 사이의 문자  
- \s ('space(공백)'의 ‘s’) : 스페이스, 탭(\t), 줄 바꿈(\n)을 비롯하여 아주 드물게 쓰이는 \v, \f, \r 을 포함하는 공백 기호  
- \w ('word(단어)'의 ‘w’) : ‘단어에 들어가는’ 문자로 라틴 문자나 숫자, 밑줄 _을 포함합니다. 키릴 문자나 힌디 문자같은 비 라틴 문자는 \w에 포함되지 않습니다.  


```js
let str = "+7(903)-123-45-67";
let regexp = /\d/;
alert( str.match(regexp) ); // 7
---
let str = "+7(903)-123-45-67";
let regexp = /\d/g;
alert( str.match(regexp) ); // 일치하는 문자의 배열: 7,9,0,3,1,2,3,4,5,6,7
// 이 배열로 숫자만 있는 전화번호를 만듭시다.
alert( str.match(regexp).join('') ); // 79035419441
---
let str = "Is there CSS4?";
let regexp = /CSS\d/;

alert( str.match(regexp) ); // CSS4
---
alert( "I love HTML5!".match(/\s\w\w\w\w\d/) ); // ' HTML5'


```

### 반대 클래스  

'반대’란 다음 예시들처럼 해당 문자를 제외한 모든 문자에 일치한다는 뜻입니다.  

- \D 숫자가 아닌 문자: \d와 일치하지 않는 일반 글자 등의 모든 문자  
- \S 공백이 아닌 문자: \s와 일치하지 않는 일반 글자 등의 모든 문자  
- \W 단어에 들어가지 않는 문자: \w와 일치하지 않는 비 라틴 문자나 공백 등의 모든 문자   

```js
let str = "+7(903)-123-45-67";
alert( str.match(/\d/g).join('') ); // 79031234567
--- 
let str = "+7(903)-123-45-67";
alert( str.replace(/\D/g, "") ); // 79031234567
```


### 점은 '아무 문자’에나 일치
- 기본적으로는 점은 줄 바꿈 문자 \n와는 일치하지 않습니다.  

```js
alert( "Z".match(/./) ); // Z
let regexp = /CS.4/;
alert( "CSS4".match(regexp) ); // CSS4
alert( "CS-4".match(regexp) ); // CS-4
alert( "CS 4".match(regexp) ); // CS 4 (공백도 문자예요.)
alert( "CS4".match(/CS.4/) ); // null, 점과 일치하는 문자가 없기 때문에 일치 결과가 없습니다.
```  

### ‘s’ 플래그와 점을 사용해 정말로 모든 문자 찾기  
- 줄바꿈 문자는 특별하게 취급되어 점으로 일치시킬 수 없다.    

```js
alert( "A\nB".match(/A.B/) ); // null (일치하지 않음)
alert( "A\nB".match(/A.B/s) ); // A\nB (일치!)
//어느 브라우저에서나 쓸 수 있는 대안
alert( "A\nB".match(/A[\s\S]B/) ); // A\nB (일치!)
alert( "1 - 5".match(/\d-\d/) ); // null, 일치 결과 없음!
alert( "1 - 5".match(/\d - \d/) ); // 1 - 5, 이제 제대로 되네요.
// \s 클래스를 사용해도 됩니다.
alert( "1 - 5".match(/\d\s-\s\d/) ); // 1 - 5, 이것도 됩니다.

```

요약 정리  
```
문자 클래스에는 다음 클래스들이 있습니다.
\d – 숫자
\D – 숫자가 아닌 문자
\s – 스페이스, 탭, 줄 바꿈 문자
\S – \s를 제외한 모든 문자
\w – 라틴 문자, 숫자, 밑줄 '_'
\W – \w를 제외한 모든 문자
. – 정규 표현식 's' 플래그가 있으면 모든 문자, 없으면 줄 바꿈 \n을 제외한 모든 문자
```


# 3.유니코드: 'u' 플래그와 \p{...} 클래스

자바스크립트는 문자열에 유니코드 인코딩을 사용.  
- 대부분의 문자는 2바이트로 인코딩, 최대 65,536개의 글자밖에 표현  
- 그래서 일부 문자는 4바이트로 인코딩되어있습니다. 예를 들면 𝒳(수학에서 사용하는 X)나 😄(웃는 표정), 일부 상형 문자  

```js
alert('😄'.length); // 2
```
- length는 4바이트 문자를 2바이트 문자 2개로 취급.   
- 이런 문자를 '서로게이트 쌍’이라고 한다.  
- 기본적으로는 정규 표현식도 4바이트의 '긴 문자’를 2바이트 문자 2개로 취급하여, 이를 해결할 수 있는 플래고 "u"를 지원  

### 참고) 유니코드    

아스키(ASCII)는 7Bit로 인코딩 되어 128개 문자를 포현.  
- 영문자, 숫자, 특수 문자, 제어문자  
유니코드(Unicode): 21비트로 인코딩되어 1,114,112개의 문자(0x0000-0x10FFFF)를 표현할 수 있습니다.   
- 전 세계 모든 언어의 문자, 기호, 이모티콘 등을 포함.  

UTF-8:
- 가변 길이 인코딩 방식. / 1바이트에서 4바이트로 문자 표현.  
- ASCII와 호환됨. 영어와 같은 라틴 문자는 1바이트로, 다른 문자는 2~4바이트로 인코딩.  
- 효율적이고 널리 사용됨.  

UTF-16:
- 가변 길이 인코딩 방식. / 2바이트 또는 4바이트로 문자 표현.  
- 대부분의 일반적인 문자는 2바이트로 인코딩.  
- BMP(기본 다국어 평면) 문자는 2바이트, 그 외의 문자는 4바이트로 인코딩.  

UTF-32:  
- 고정 길이 인코딩 방식. / 모든 문자를 4바이트로 표현.  
- 모든 문자를 같은 길이로 인코딩하므로 단순하지만 비효율적일 수 있음.  
- 메모리 사용량이 많음.  

## 유니코드 프로퍼티 \p{…}

유니코드 문자는 내부적으로 프로퍼티를 가지고 있다. 같은 문자열 임에도 유니코드상으로 Letter에 속하는지 아니면 Number에 속하는지 알 수 있다.  
- 그 외, 소문자, 대문자, 대시, 통화 기호, 공백 등등 다양한 범주가 있다.  
- 이러한 프로퍼티를 사용하려면 p를 이용하면 된다.  

```js
let str = "A ბ ㄱ";
// 유니코드의 문자열 프로퍼티를 grap한다.   
alert( str.match(/\p{L}/gu) ); // A,ბ,ㄱ
alert( str.match(/\p{L}/g) ); // null ('u' 플래그가 없어서 일치 결과 없음)
---
// 예시: 16진수
let regexp = /x\p{Hex_Digit}\p{Hex_Digit}/u;
alert("number: xAF".match(regexp)); // xAF
---
// 예시: 한자
let regexp = /\p{sc=Han}/gu; // 한자를 반환
let str = `Hello Привет 你好 123_456`;
alert( str.match(regexp) ); // 你,好
---
// 예시: 통화
let regexp = /\p{Sc}\d/gu;
let  str = `Prices: $2, €1, ¥9`;
alert( str.match(regexp) ); // $2,€1,¥9  

```

# 4.앵커: 문자열의 시작 ^과 끝 $  

캐럿(caret) 기호 ^와 달러 기호 $는 정규식에서 특별한 뜻을 가진다.  
- 앵커 라고 하며, 조건패턴에 해당 한다.    

- ^ : 특정 문자열로 시작하는지 판단 가능  
- $ : 특정 문자열로 끝나는지 판단 가능  
- ^...$ : 한 행이 특정 패턴으로 시작해서 끝나는지, 완전 일치 판단 가능    
  - ^$와 일치하는 문자열은 어떤 문자열은 빈문자열 뿐.  


```js
// 텍스트가 Mary로 시작하는지 검사해보죠.

let str1 = "Mary had a little lamb";
alert( /^Mary/.test(str1) ); // true
--- 
//문자열이 snow로 끝나는지 검사
let str1 = "it's fleece was white as snow";
alert( /snow$/.test(str1) ); // true
---
// 완전 일치 판단  
let goodInput = "12:34";
let badInput = "12:345";

let regexp = /^\d\d:\d\d$/;
alert( regexp.test(goodInput) ); // true
alert( regexp.test(badInput) ); // false
---
```

# 5.앵커 ^와 $의 여러 행 모드, 'm' 플래그  

>\n 개행을 기준으로 여러행들을 모두 검사하고 싶다면 m(멀티라인) 플래그 사용할것.  

m 플래그를 사용하면 여러 행 모드(multiline mode)를 활성화 가능  
- 여러 행 모드는 ^와 $의 작동 방식에만 영향  
- 여러 행 모드에서는 두 앵커가 전체 문자열의 처음과 끝뿐 아니라 각 행의 시작과 끝에도 대응합니다.  

```js
let str = `1st place: Winnie
2nd place: Piglet
3rd place: Eeyore`;
alert( str.match(/^\d/gm) ); // 1, 2, 3
---
let str = `1st place: Winnie
2nd place: Piglet
3rd place: Eeyore`;
alert( str.match(/^\d/g) ); // 1
---
let str = `Winnie: 1
Piglet: 2
Eeyore: 3`;
alert( str.match(/\d$/gm) ); // 1,2,3
---
// 줄 바꿈을 찾을 때는 앵커 ^ $뿐 아니라 줄 바꿈 문자 \n을 사용 가능.  
// 하지만 grap된다.  
let str = `Winnie: 1
Piglet: 2
Eeyore: 3`;
alert( str.match(/\d\n/gm) ); // 1\n,2\n
```

정규식에는 2가지 패턴이 있다.  
- 문자열을 소비하는 (grap) 패턴  
- 그렇지 않은 Condition 패턴  

# 6.Word boundary: \b  

단어경계 클래스는 `\b` 로 표현한다.  
- 문장의 시자과 끝 조건을 거는 앵커(^$) 패턴처럼 사용한다.  
- 단어를 분리하고 싶을때 사용될 수 있다.  
- 단어 앞뒤로 공백,특수문자 등으로 단어가 아닌지 "조건"을 체크한다.  

3가지 조건을 본다.  
- 문자열 시작 시 첫 번째 문자열 문자가 단어 문자인 경우 \w.  
- 문자열 끝에서 마지막 문자열 문자가 단어 문자인 경우 \w.
- 문자열의 경계의 두 문자 사이에서 하나는 단어 문자 \w이고 다른 하나는 그렇지 않습니다.   
- *쉽게 생각하면 단어 경계 지점은 
```
Java!라는 단어가 있다면 단어와 단어 사이 가림막이 존재한다고 생각하자.
|J|a|v|a|!|
o x x x o x  
가림막 기준으로 앞뒤 문자 중 하나만 \w일때 참이다.  
```

```js
// 독립된 Java라는 문자가 있다.  
alert( "Hello, Java!".match(/\bJava\b/) ); // Java

// JavaScript라는 문자가 있지 Java는 없다.  
alert( "Hello, JavaScript!".match(/\bJava\b/) ); // null
---
// H앞은 단어 문자 아니라 ok, o뒤부분은 특수문자라 ok  
alert( "Hello, Java!".match(/\bHello\b/) ); // Hello
alert( "Hello, Java!".match(/\bJava\b/) );  // Java
// l뒤 o는 문자여서 No  
alert( "Hello, Java!".match(/\bHell\b/) );  // null (no match)
// 아래 경우는 무쓸모 짓인데, !뒤에 단어가 아니라ok인데 !본인도 단어가 아니라서 결국 단어 경계라고 볼 수 없다.  
alert( "Hello, Java!".match(/\bJava!\b/) ); // null (no match)
---
alert( "1 23 456 78".match(/\b\d\d\b/g) ); // 23,78
alert( "12,34,56".match(/\b\d\d\b/g) ); // 12,34,56
---

//eg) 09:00 만 선택하시오. 
"Breakfast at 09:00 in the room 123:456."

alert( "Breakfast at 09:00 in the room 123:456.".match( /\b\d\d:\d\d\b/ ) ); // 09:00
```